<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Realistic 3D Arm (Flexion/Extension)</title>
  <style>
    :root{
      --panel: rgba(255,255,255,.86);
      --panel2: rgba(255,255,255,.75);
      --ink: #111;
      --muted:#444;
      --accent:#1f6feb;
      --danger:#d11b1b;
      --ok:#1b7a3a;
      --border: rgba(0,0,0,.10);
      --shadow: 0 10px 22px rgba(0,0,0,.18);
      --radius: 14px;
    }
    body{
      margin:0;
      overflow:hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      /* Studio-like background (similar to reference) */
      background: radial-gradient(1200px 900px at 65% 35%, #3a3a3a 0%, #1f1f1f 40%, #0f0f10 100%);
      color: var(--ink);
    }
    #stage{
      width:100vw;height:100vh;
      position:relative;
    }

    /* Top-right actions */
    #top-actions{
      position:fixed;
      top: 110px; right:16px;
      z-index: 50;
      display:flex;
      gap:10px;
      align-items:center;
    }
    .btn{
      border:1px solid var(--border);
      background: var(--panel);
      color: var(--ink);
      border-radius: 999px;
      padding: 10px 14px;
      font-weight: 700;
      cursor:pointer;
      box-shadow: var(--shadow);
      user-select:none;
      display:flex;
      gap:8px;
      align-items:center;
      transition: transform 120ms ease, background 120ms ease;
    }
    .btn:hover{ transform: translateY(-1px); background: rgba(255,255,255,.92); }
    .btn:active{ transform: translateY(0px); }
    .pill{
      border:1px solid var(--border);
      background: var(--panel2);
      border-radius: 999px;
      padding: 10px 14px;
      box-shadow: var(--shadow);
      font-weight: 700;
      color: var(--muted);
      user-select:none;
    }

    /* Bottom control bar (different from heart model) */
    #control-bar{
      position:fixed;
      left:50%;
      transform: translateX(-50%);
      top:16px;
      z-index: 60;
      width: min(960px, calc(100vw - 32px));
      background: rgba(255,255,255,.86);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 12px 14px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px 14px;
      backdrop-filter: blur(10px);
    }
    .card{
      background: rgba(255,255,255,.72);
      border:1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      display:flex;
      align-items:center;
      gap:12px;
      min-height: 48px;
    }
    .label{
      font-weight:800;
      color:#111;
      font-size: 12px;
      letter-spacing: .02em;
      text-transform: uppercase;
      opacity:.9;
      min-width: 128px;
    }
    .hint{
      font-size:12px;color:var(--muted);
      margin-left:auto;
      white-space: nowrap;
    }

    /* Toggle */
    #rotateToggle{
      background: rgba(31,111,235,.10);
      border:1px solid rgba(31,111,235,.25);
    }
    #rotateToggle.enabled{
      background: rgba(27,122,58,.12);
      border-color: rgba(27,122,58,.25);
    }

    /* Slider */
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    #angleReadout{
      font-variant-numeric: tabular-nums;
      font-weight: 900;
      color:#111;
    }
    #status{
      font-weight: 900;
      font-variant-numeric: tabular-nums;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.75);
    }
    #status.safe{ color: var(--ok); }
    #status.risky{ color: #c05a00; }
    #status.injury{ color: var(--danger); border-color: rgba(209,27,27,.35); background: rgba(209,27,27,.08); }

    /* Bottom-left explanation panel */
    #explain{
      position:fixed;
      left:16px;
      bottom: 16px; /* bottom-left panel */
      z-index: 55;
      width: min(420px, calc(100vw - 32px));
      background: rgba(255,255,255,.86);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px 14px 12px 14px;
      backdrop-filter: blur(10px);
    }
    #explain h2{
      margin:0 0 6px 0;
      font-size: 15px;
      letter-spacing:.01em;
    }
    #explain p{
      margin:0;
      color:#222;
      line-height:1.45;
      font-size: 13px;
    }
    #explain small{
      display:block;
      margin-top: 10px;
      color: var(--muted);
      font-size: 12px;
    }

    /* Floating click labels */
    .tag{
      position: absolute;
      z-index: 70;
      pointer-events: auto;
      background: rgba(255,255,255,.88);
      border: 1px solid rgba(0,0,0,.12);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      font-weight: 800;
      color:#111;
      box-shadow: 0 8px 18px rgba(0,0,0,.16);
      cursor:pointer;
      user-select:none;
      transform: translate(-50%, -50%);
      white-space: nowrap;
      transition: transform 120ms ease, background 120ms ease;
    }
    .tag:hover{ background: rgba(255,255,255,.95); transform: translate(-50%,-50%) scale(1.04); }
    .tag.selected{
      background: rgba(31,111,235,.12);
      border-color: rgba(31,111,235,.28);
    }

    /* Injury overlay text */
    #injuryBanner{
      position: fixed;
      left: 16px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 80;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid rgba(209,27,27,.35);
      background: rgba(209,27,27,.10);
      color: #fff;
      box-shadow: var(--shadow);
      display:none;
      backdrop-filter: blur(10px);
    }
    #injuryBanner b{ color:#fff; }
    #injuryBanner span{ opacity:.95; }

    /* Mobile tweaks */
    @media (max-width: 700px){
      #control-bar{ grid-template-columns: 1fr; }
      #explain{ bottom: 170px; }
      .label{ min-width: 112px; }
    }
  
    /* Loader overlay */
    #loader{
      position:fixed;
      inset:0;
      z-index: 200;
      display:flex;
      align-items:center;
      justify-content:center;
      background: radial-gradient(1200px 900px at 65% 35%, rgba(58,58,58,.98) 0%, rgba(31,31,31,.98) 40%, rgba(15,15,16,.98) 100%);
      color:#fff;
    }
    #loaderCard{
      width: min(520px, calc(100vw - 48px));
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 18px;
      padding: 18px 18px 16px 18px;
      box-shadow: 0 18px 42px rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
    }
    #loaderTitle{
      font-weight: 900;
      letter-spacing: .02em;
      font-size: 16px;
      margin: 0 0 8px 0;
    }
    #loaderSub{
      margin: 0 0 14px 0;
      opacity: .9;
      font-size: 13px;
      line-height: 1.4;
    }
    #barOuter{
      height: 12px;
      border-radius: 999px;
      background: rgba(255,255,255,.14);
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.18);
    }
    #barInner{
      height: 100%;
      width: 0%;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(31,111,235,.95), rgba(56,189,248,.95));
      box-shadow: 0 0 22px rgba(56,189,248,.35);
      transition: width 120ms linear;
    }
    #loaderPct{
      margin-top: 10px;
      font-weight: 800;
      font-variant-numeric: tabular-nums;
      opacity: .9;
      font-size: 12px;
      text-align:right;
    }

    /* Sparkles for pop-out reveal */
    .spark{
      position: fixed;
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,.92);
      box-shadow: 0 0 18px rgba(56,189,248,.65), 0 0 34px rgba(31,111,235,.35);
      pointer-events:none;
      z-index: 190;
      opacity: 0;
      transform: translate(-50%,-50%) scale(0.5);
      animation: spark 900ms ease-out forwards;
    }
    @keyframes spark{
      0%   { opacity: 0; transform: translate(-50%,-50%) scale(0.4); }
      12%  { opacity: 1; }
      100% { opacity: 0; transform: translate(var(--dx), var(--dy)) scale(0.2); }
    }

  
    /* Injury magnifier (shows crack image) */
    #magnifier{
      position: fixed;
      right: 18px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 85;
      display: none;
      width: 210px;
      height: 210px;
      border-radius: 999px;
      background: rgba(255,255,255,.10);
      border: 2px solid rgba(255,255,255,.75);
      box-shadow: 0 18px 40px rgba(0,0,0,.40);
      backdrop-filter: blur(10px);
      overflow: hidden;
    }
    #magnifier:before{
      content:"";
      position:absolute;
      inset:10px;
      border-radius:999px;
      border: 1px dashed rgba(255,255,255,.65);
      opacity:.9;
      pointer-events:none;
    }
    #magnifierLabel{
      position:absolute;
      left: 50%;
      top: -36px;
      transform: translateX(-50%);
      font-size: 12px;
      font-weight: 900;
      letter-spacing:.02em;
      color: rgba(255,255,255,.98);
      text-shadow: 0 2px 12px rgba(0,0,0,.65);
      user-select:none;
      white-space:nowrap;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.25);
      padding: 6px 10px;
      border-radius: 999px;
    }
    #magnifier svg{
      width: 100%;
      height: 100%;
      display:block;
    }
    #magnifier.show{
      display:block;
      animation: magIn 220ms ease-out forwards;
    }
    @keyframes magIn{
      from{ opacity:0; transform: translateY(-50%) scale(0.92); }
      to{ opacity:1; transform: translateY(-50%) scale(1.0); }
    }

  
    /* Injury banner animation */
    @keyframes injuryPop {
      0%   { transform: translateY(-50%) scale(0.92); opacity: 0; }
      55%  { transform: translateY(-50%) scale(1.03); opacity: 1; }
      100% { transform: translateY(-50%) scale(1.0); opacity: 1; }
    }
    @keyframes injuryPulse {
      0%,100% { box-shadow: 0 10px 22px rgba(0,0,0,.18); }
      50% { box-shadow: 0 16px 34px rgba(209,27,27,.22); }
    }
    #injuryBanner.show{
      display:block !important;
      animation: injuryPop 260ms ease-out both, injuryPulse 1.2s ease-in-out infinite;
    }

  
    #muteBtn.muted{ background: rgba(0,0,0,.08); }

  </style>
</head>
<body>
  <div id="stage"></div>

  <div id="loader" aria-label="Loading">
    <div id="loaderCard">
      <div id="loaderTitle">Preparing 3D Model of Arm</div>
      <div id="loaderSub"></div>
      <div id="barOuter"><div id="barInner"></div></div>
      <div id="loaderPct">0%</div>
    </div>
  </div>


  <div id="top-actions">
    <div class="pill" id="zoomPill">üîç Zoom: Normal</div>
    <button class="btn" id="resetBtn">‚Ü∫ Reset</button>
    <button class="btn" id="muteBtn">üîä Sound On</button>

  </div>

  <div id="injuryBanner">
    <b>Injury threshold reached</b><br/>
    
  </div>


  <div id="magnifier" aria-hidden="true">
    <!-- Inline stylized "bone crack" image () -->
    <svg viewBox="0 0 220 220" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <radialGradient id="g" cx="50%" cy="45%" r="70%">
          <stop offset="0%" stop-color="rgba(255,255,255,0.95)"/>
          <stop offset="70%" stop-color="rgba(235,225,210,0.95)"/>
          <stop offset="100%" stop-color="rgba(210,198,180,0.95)"/>
        </radialGradient>
        <filter id="glow" x="-20%" y="-20%" width="140%" height="140%">
          <feGaussianBlur stdDeviation="2.5" result="b"/>
          <feMerge>
            <feMergeNode in="b"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
      </defs>

      <!-- background vignette -->
      <circle cx="110" cy="110" r="110" fill="rgba(0,0,0,0.25)"/>
      <circle cx="110" cy="110" r="100" fill="rgba(0,0,0,0.15)"/>

      <!-- "bone" -->
      <g transform="translate(0,0)">
        <rect x="52" y="70" width="116" height="80" rx="34" fill="url(#g)" stroke="rgba(255,255,255,0.35)" stroke-width="2"/>
        <circle cx="58" cy="110" r="34" fill="url(#g)" stroke="rgba(255,255,255,0.35)" stroke-width="2"/>
        <circle cx="162" cy="110" r="34" fill="url(#g)" stroke="rgba(255,255,255,0.35)" stroke-width="2"/>
      </g>

      <!-- crack -->
      <path d="M110 65 L102 92 L122 105 L108 124 L125 138 L114 160"
            fill="none" stroke="rgba(255,255,255,0.95)" stroke-width="4"
            stroke-linecap="round" stroke-linejoin="round" filter="url(#glow)"/>
      <path d="M110 65 L102 92 L122 105 L108 124 L125 138 L114 160"
            fill="none" stroke="rgba(255,45,45,0.75)" stroke-width="2.2"
            stroke-linecap="round" stroke-linejoin="round"/>

      <!-- small fracture sparks -->
      <g stroke="rgba(255,255,255,0.9)" stroke-width="2" stroke-linecap="round">
        <path d="M128 98 l16 -10"/>
        <path d="M95 122 l-18 8"/>
        <path d="M134 138 l14 16"/>
      </g>
    </svg>
    <div id="magnifierLabel">Bone crack close‚Äëup</div>
  </div>


  <div id="explain">
    <h2 id="exTitle">Click a label</h2>
    <p id="exBody">Select a part to see an explanation here. Rotation is locked by default so clicks select anatomy.</p>
    <small>Tip: enable rotation to orbit, drag to rotate, scroll/pinch to zoom.</small>
  </div>

  <div id="control-bar">
    <div class="card">
      <div class="label">Rotation</div>
      <button class="btn" id="rotateToggle" title="Enable/disable rotation">üîí Locked</button>
      <div class="hint">Click labels while locked</div>
    </div>

    <div class="card">
      <div class="label">Elbow angle</div>
      <input id="angle" type="range" min="-20" max="160" value="25" step="1"/>
      <div id="angleReadout">25¬∞</div>
      <div id="status" class="safe">SAFE</div>
    </div>
  </div>

  <!-- three.js (non-module build) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    /* ========= Scene ========= */
    let scene, camera, renderer;
    let raycaster, mouse;
    let isDragging=false, dragEnabled=false;
    let prev = {x:0,y:0};
    let orbit = {x:0.25,y:-0.6};

    // Arm rig groups
    let rigRoot, upperGroup, foreGroup, handGroup;
    let tags = [];
    let selected = null;

    // Injury visuals
    let injuryLines = null;
    let injuryActive = false;
    // Simple injury sound (WebAudio). Plays once each time injury threshold is crossed into injury.
    let audioCtx = null;
    function playInjurySound(){
      if(!soundEnabled) return;
      try{
        if(!audioCtx){
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        const now = audioCtx.currentTime;

        // short "snap" + low thump (non-scary)
        const osc1 = audioCtx.createOscillator();
        const gain1 = audioCtx.createGain();
        osc1.type = "square";
        osc1.frequency.setValueAtTime(520, now);
        osc1.frequency.exponentialRampToValueAtTime(180, now + 0.08);
        gain1.gain.setValueAtTime(0.0001, now);
        gain1.gain.exponentialRampToValueAtTime(0.18, now + 0.01);
        gain1.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);
        osc1.connect(gain1).connect(audioCtx.destination);
        osc1.start(now);
        osc1.stop(now + 0.14);

        const osc2 = audioCtx.createOscillator();
        const gain2 = audioCtx.createGain();
        osc2.type = "sine";
        osc2.frequency.setValueAtTime(110, now);
        osc2.frequency.exponentialRampToValueAtTime(70, now + 0.18);
        gain2.gain.setValueAtTime(0.0001, now);
        gain2.gain.exponentialRampToValueAtTime(0.10, now + 0.02);
        gain2.gain.exponentialRampToValueAtTime(0.0001, now + 0.22);
        osc2.connect(gain2).connect(audioCtx.destination);
        osc2.start(now);
        osc2.stop(now + 0.24);
      }catch(e){
        // If autoplay blocked, ignore silently.
      }
    }
    let lastInjury = false;

    let soundEnabled = true;
    const muteBtn = document.getElementById("muteBtn");
    if(muteBtn){
      muteBtn.addEventListener("click", ()=>{
        soundEnabled = !soundEnabled;
        muteBtn.textContent = soundEnabled ? "üîä Sound On" : "üîá Muted";
        muteBtn.classList.toggle("muted", !soundEnabled);
      });
    }


    let cameraTargetZ = 8.2;
    let cameraZ = 8.2;

    const explain = {
      humerus: {
        title: "Humerus (upper arm bone)",
        body: "The humerus connects the shoulder to the elbow. It forms joints with the scapula/shoulder complex and the ulna/radius at the elbow."
      },
      radius: {
        title: "Radius",
        body: "The radius is the lateral forearm bone (thumb-side). It rotates around the ulna during pronation/supination."
      },
      ulna: {
        title: "Ulna",
        body: "The ulna is the medial forearm bone (pinky-side). It forms the hinge-like articulation at the elbow with the humerus."
      },
      biceps: {
        title: "Biceps brachii",
        body: "Primary elbow flexor (and forearm supinator). Contracts to bend the elbow and assist shoulder flexion."
      },
      triceps: {
        title: "Triceps brachii",
        body: "Primary elbow extensor. Contracts to straighten the elbow and stabilize the joint."
      },
      deltoid: {
        title: "Deltoid (simplified)",
        body: "Major shoulder muscle. In this demo it helps visually anchor the upper arm to the shoulder region."
      },
      skin: {
        title: "Skin surface (stylized)",
        body: "A smooth outer mesh to make the arm look more realistic. You can still select internal parts via labels."
      },
      joint: {
        title: "Elbow joint",
        body: "A hinge-like joint for flexion/extension. Hyperextension (below ~0¬∞) or extreme flexion can exceed safe limits."
      },
      hand: {
        title: "Hand (simplified)",
        body: "A simplified hand shape for context (not a full carpal/metacarpal/phalange model in this version)."
      }
    };

    function init(){
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 200);
      camera.position.set(0, 1.0, cameraZ);

      renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.05;
      document.getElementById("stage").appendChild(renderer.domElement);

      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      // Lights: studio-ish
      const hemi = new THREE.HemisphereLight(0xffffff, 0x2a2a2a, 0.70);
      hemi.position.set(0, 5, 0);
      scene.add(hemi);

      const key = new THREE.DirectionalLight(0xffffff, 0.95);
      key.position.set(3.5, 4.5, 3.0);
      key.castShadow = false;
      scene.add(key);

      const fill = new THREE.DirectionalLight(0xffffff, 0.35);
      fill.position.set(-3.5, 2.5, 1.5);
      scene.add(fill);

      const rim = new THREE.DirectionalLight(0xffffff, 0.55);
      rim.position.set(0.0, 2.0, -4.5);
      scene.add(rim);

      createArmRig();
      createTags();

      // Start hidden until load animation completes
      setUiVisible(false);
      if (rigRoot) { rigRoot.scale.set(0.15,0.15,0.15); rigRoot.rotation.z -= 0.35; }
      startLoaderSequence();

      // UI handlers
      document.getElementById("rotateToggle").addEventListener("click", toggleRotation);
      document.getElementById("resetBtn").addEventListener("click", resetAll);
      document.getElementById("angle").addEventListener("input", (e)=>setElbowAngle(parseFloat(e.target.value)));

      // interactions
      renderer.domElement.addEventListener("mousedown", onDown);
      renderer.domElement.addEventListener("mousemove", onMove);
      renderer.domElement.addEventListener("mouseup", onUp);
      renderer.domElement.addEventListener("wheel", onWheel, {passive:false});
      renderer.domElement.addEventListener("click", onCanvasClick);
      window.addEventListener("resize", onResize);

      // Start angle
      setElbowAngle(parseFloat(document.getElementById("angle").value));
      animate();
    }

    /* ========= Geometry helpers (more realistic look without external assets) ========= */
    function capsule(r, h, radial=32, capSeg=16){
      // THREE.CapsuleGeometry exists in newer versions; r128 doesn't include it reliably.
      // So we build a "capsule" by merging a cylinder with two spheres (kept separate but grouped).
      const g = new THREE.Group();
      const cyl = new THREE.Mesh(new THREE.CylinderGeometry(r, r, h, radial, 1, true), null);
      const sTop = new THREE.Mesh(new THREE.SphereGeometry(r, radial, capSeg), null);
      const sBot = new THREE.Mesh(new THREE.SphereGeometry(r, radial, capSeg), null);
      sTop.position.y = h/2;
      sBot.position.y = -h/2;
      g.add(cyl, sTop, sBot);
      return g;
    }

    function standardMat(color, rough=0.55, metal=0.0){
      return new THREE.MeshStandardMaterial({
        color: new THREE.Color(color),
        roughness: rough,
        metalness: metal
      });
    }

    function createArmRig(){
      rigRoot = new THREE.Group();
      rigRoot.position.set(0, 0.75, 0);
      scene.add(rigRoot);

      // Upper arm group
      upperGroup = new THREE.Group();
      rigRoot.add(upperGroup);

      // Forearm group pivot at elbow
      foreGroup = new THREE.Group();
      foreGroup.position.set(0, -1.05, 0); // elbow pivot relative to upper
      upperGroup.add(foreGroup);

      // Materials (skin slightly glossy)
      const skinMat = standardMat("#d8a38a", 0.42, 0.0);
      skinMat.emissive = new THREE.Color("#220b06");
      skinMat.emissiveIntensity = 0.06;

      const boneMat = standardMat("#efe9db", 0.65, 0.0);
      const muscleMat1 = standardMat("#b01822", 0.55, 0.0);
      const muscleMat2 = standardMat("#8f0f1a", 0.55, 0.0);
      const tendonMat = standardMat("#d7c9b0", 0.70, 0.0);

      // ===== Upper arm (skin surface) =====
      const upperSkin = capsule(0.40, 1.80, 36, 18);
      upperSkin.name = "skin";
      upperSkin.userData = { key:"skin", clickable:false };
      upperSkin.traverse(o=>{ if(o.isMesh) o.material = skinMat; });
      upperSkin.position.set(0, -0.20, 0);
      upperSkin.scale.set(1.0, 1.0, 0.92);
      upperGroup.add(upperSkin);

      // Shoulder bulge (deltoid volume)
      const deltoid = capsule(0.47, 0.55, 32, 16);
      deltoid.name = "deltoid";
      deltoid.userData = { key:"deltoid", clickable:false };
      deltoid.traverse(o=>{ if(o.isMesh) o.material = standardMat("#d1a08a", 0.40, 0.0); });
      deltoid.position.set(0.05, 0.85, 0.05);
      deltoid.rotation.z = 0.25;
      deltoid.scale.set(1.05, 1.0, 0.95);
      upperGroup.add(deltoid);

      // Humerus (inside)
      const hum = new THREE.Mesh(new THREE.CylinderGeometry(0.13, 0.14, 1.65, 20), boneMat);
      hum.position.set(0, -0.22, 0.02);
      hum.rotation.z = 0.02;
      hum.name = "humerus";
      hum.userData = { key:"humerus", clickable:true };
      upperGroup.add(hum);

      // Biceps (inside, anterior)
      const biceps = capsule(0.18, 1.10, 28, 14);
      biceps.name = "biceps";
      biceps.userData = { key:"biceps", clickable:true };
      biceps.traverse(o=>{ if(o.isMesh) o.material = muscleMat1; });
      biceps.position.set(0.10, -0.08, 0.22);
      biceps.rotation.z = -0.08;
      upperGroup.add(biceps);

      // Triceps (inside, posterior)
      const triceps = capsule(0.20, 1.20, 28, 14);
      triceps.name = "triceps";
      triceps.userData = { key:"triceps", clickable:true };
      triceps.traverse(o=>{ if(o.isMesh) o.material = muscleMat2; });
      triceps.position.set(-0.02, -0.12, -0.24);
      triceps.rotation.z = 0.10;
      upperGroup.add(triceps);

      // Elbow joint marker (small ring)
      const jointRing = new THREE.Mesh(new THREE.TorusGeometry(0.30, 0.03, 12, 44), tendonMat);
      jointRing.position.set(0, -1.05, 0);
      jointRing.rotation.x = Math.PI/2;
      jointRing.name="joint";
      jointRing.userData = { key:"joint", clickable:true };
      upperGroup.add(jointRing);

      // ===== Forearm =====
      const foreSkin = capsule(0.34, 1.55, 36, 18);
      foreSkin.name = "skin";
      foreSkin.userData = { key:"skin", clickable:false };
      foreSkin.traverse(o=>{ if(o.isMesh) o.material = skinMat; });
      foreSkin.position.set(0, -0.80, 0);
      foreSkin.scale.set(1.0, 1.0, 0.88);
      foreGroup.add(foreSkin);

      // Radius + Ulna (inside)
      const radius = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.10, 1.42, 18), boneMat);
      radius.position.set(0.10, -0.80, 0.10);
      radius.rotation.z = 0.03;
      radius.name = "radius";
      radius.userData = { key:"radius", clickable:true };
      foreGroup.add(radius);

      const ulna = new THREE.Mesh(new THREE.CylinderGeometry(0.095, 0.11, 1.44, 18), boneMat);
      ulna.position.set(-0.09, -0.80, -0.02);
      ulna.rotation.z = -0.02;
      ulna.name = "ulna";
      ulna.userData = { key:"ulna", clickable:true };
      foreGroup.add(ulna);

      // Tendon-ish strap near elbow (visual)
      const tendon = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.09, 0.40, 18), tendonMat);
      tendon.position.set(0.10, -0.10, 0.20);
      tendon.rotation.z = -0.20;
      foreGroup.add(tendon);

      // Hand group at wrist
      handGroup = new THREE.Group();
      handGroup.position.set(0, -1.58, 0);
      foreGroup.add(handGroup);

      // Palm (smoother, rounded)
      const palmMat = standardMat("#d6a08a", 0.45, 0);
      const palmGroup = capsule(0.18, 0.55, 28, 14);
      palmGroup.traverse(o=>{ if(o.isMesh) o.material = palmMat; });
      palmGroup.position.set(0.02, -0.24, 0.10);
      palmGroup.rotation.x = 0.10;
      palmGroup.rotation.z = -0.02;
      palmGroup.scale.set(1.35, 0.70, 1.55);
      palmGroup.name="hand";
      palmGroup.userData = { key:"hand", clickable:true };
      palmGroup.traverse(o=>{ if(o.isMesh){ o.userData = palmGroup.userData; o.name="hand"; }});
      handGroup.add(palmGroup);

      // Fingers (simple tapered capsules)
      function finger(x,z,len,rotZ){
        const f = capsule(0.07, len, 18, 10);
        f.traverse(o=>{ if(o.isMesh) o.material = standardMat("#d6a08a", 0.48, 0); });
        f.position.set(x, -0.10 - len/2, z);
        f.rotation.z = rotZ;
        handGroup.add(f);
      }
      finger(-0.18, 0.32, 0.55, 0.02);
      finger(-0.05, 0.35, 0.60, 0.00);
      finger( 0.08, 0.32, 0.58,-0.01);
      finger( 0.20, 0.25, 0.52,-0.02);

      // Thumb
      const thumb = capsule(0.075, 0.40, 18, 10);
      thumb.traverse(o=>{ if(o.isMesh) o.material = standardMat("#d6a08a", 0.48, 0); });
      thumb.position.set(0.30, -0.05, 0.02);
      thumb.rotation.z = -0.9;
      thumb.rotation.x = 0.35;
      handGroup.add(thumb);

      // Slight overall pose (like reference)
      rigRoot.rotation.y = -0.15;
      rigRoot.rotation.x = 0.08;

      // Injury lines (hidden by default)
      injuryLines = makeInjuryLines();
      injuryLines.visible = false;
      foreGroup.add(injuryLines);

      // Extra tear/crack effect (muscle tear look)
      const tearLines = makeInjuryLines();
      tearLines.traverse(o=>{
        if(o.material){
          o.material.color.set(0xff2222);
          o.material.opacity = 0.9;
        }
      });
      tearLines.visible = false;
      foreGroup.add(tearLines);
      foreGroup.userData.tearLines = tearLines;

    }

    function makeInjuryLines(){
      const g = new THREE.Group();

      function ring(radius, y, color){
        const geom = new THREE.TorusGeometry(radius, 0.01, 10, 72);
        const mat = new THREE.MeshBasicMaterial({color: color, transparent:true, opacity:0.9});
        const mesh = new THREE.Mesh(geom, mat);
        mesh.position.set(0, y, 0);
        mesh.rotation.x = Math.PI/2;
        g.add(mesh);
      }

      // Strain rings around elbow + forearm
      ring(0.32,  0.10, 0xff4b4b);
      ring(0.30,  0.02, 0xffc04b);
      ring(0.28, -0.06, 0xff4b4b);

      // Crack-like lines ()
      const lineMat = new THREE.LineBasicMaterial({color:0xffffff, transparent:true, opacity:0.85});
      for(let i=0;i<8;i++){
        const pts=[];
        const a = (i/8)*Math.PI*2;
        const baseR=0.18;
        const x0=Math.cos(a)*baseR, z0=Math.sin(a)*baseR;
        const y0=0.05;
        pts.push(new THREE.Vector3(x0, y0, z0));
        pts.push(new THREE.Vector3(x0*1.7, y0-0.12, z0*1.7));
        pts.push(new THREE.Vector3(x0*2.2, y0-0.22, z0*2.0));
        const geom = new THREE.BufferGeometry().setFromPoints(pts);
        const line = new THREE.Line(geom, lineMat);
        g.add(line);
      }
      g.position.set(0, 0.02, 0);
      return g;
    }

    /* ========= Labels (non-colliding screen-space) ========= */
    const tagDefs = [
      {key:"deltoid", text:"Deltoid", world:()=>worldPosOfName("deltoid"), offset:{x:-70,y:-40}},
      {key:"humerus", text:"Humerus", world:()=>worldPosOfName("humerus"), offset:{x:-60,y:20}},
      {key:"biceps", text:"Biceps", world:()=>worldPosOfName("biceps"), offset:{x:80,y:0}},
      {key:"triceps", text:"Triceps", world:()=>worldPosOfName("triceps"), offset:{x:78,y:30}},
      {key:"joint", text:"Elbow joint", world:()=>worldPosOfName("joint"), offset:{x:0,y:60}},
      {key:"radius", text:"Radius", world:()=>worldPosOfName("radius"), offset:{x:80,y:-20}},
      {key:"ulna", text:"Ulna", world:()=>worldPosOfName("ulna"), offset:{x:-85,y:-10}},
      {key:"hand", text:"Hand", world:()=>worldPosOfName("hand"), offset:{x:0,y:70}},
      {key:"skin", text:"Skin surface", world:()=>approxSkinMid(), offset:{x:-85,y:-55}},
    ];

    function createTags(){
      const stage = document.getElementById("stage");
      tagDefs.forEach(def=>{
        const el = document.createElement("div");
        el.className="tag";
        el.textContent = def.text;
        el.dataset.key = def.key;
        el.addEventListener("click", (e)=>{
          e.stopPropagation();
          selectKey(def.key);
        });
        stage.appendChild(el);
        tags.push({def, el, x:0, y:0});
      });
    }

    function selectKey(key){
      selected = key;
      tags.forEach(t=>t.el.classList.toggle("selected", t.def.key===key));
      const info = explain[key] || {title:defText(key), body:""};
      document.getElementById("exTitle").textContent = info.title || defText(key);
      document.getElementById("exBody").textContent = info.body || "";
    }

    function defText(key){ return key.charAt(0).toUpperCase()+key.slice(1); }

    function worldPosOfName(name){
      const obj = scene.getObjectByName(name);
      const v = new THREE.Vector3();
      if(obj){ obj.getWorldPosition(v); return v; }
      return new THREE.Vector3();
    }
    function approxSkinMid(){
      // midway on forearm surface
      const v = worldPosOfName("radius");
      v.add(worldPosOfName("ulna")).multiplyScalar(0.5);
      v.y += 0.12; v.z += 0.18;
      return v;
    }

    function updateTags(){
      // Project to screen
      const w = window.innerWidth, h = window.innerHeight;
      const bar = document.getElementById("control-bar");
      const topSafe = (bar ? (bar.getBoundingClientRect().bottom + 14) : 34);

      // First pass: set target positions
      const pts = tags.map(t=>{
        const wp = t.def.world();
        const p = wp.clone().project(camera);
        const sx = (p.x*0.5+0.5)*w + t.def.offset.x;
        const sy = (-p.y*0.5+0.5)*h + t.def.offset.y;
        const visible = p.z < 1.0; // in front-ish
        return {t, sx, sy, visible, z:p.z};
      });

      // Collision avoidance (repulsion)
      // Work in screen space; do a few iterations of simple separation.
      const items = pts.filter(p=>p.visible);
      for(let it=0; it<8; it++){
        for(let i=0;i<items.length;i++){
          for(let j=i+1;j<items.length;j++){
            const a=items[i], b=items[j];
            const ra = rectForTag(a.t.el, a.sx, a.sy);
            const rb = rectForTag(b.t.el, b.sx, b.sy);
            if(overlap(ra, rb)){
              // push apart along the line between centers
              const ax = (ra.x + ra.w/2), ay=(ra.y + ra.h/2);
              const bx = (rb.x + rb.w/2), by=(rb.y + rb.h/2);
              let dx = ax-bx, dy=ay-by;
              const d = Math.max(0.001, Math.hypot(dx,dy));
              dx/=d; dy/=d;
              const push = 6; // px
              a.sx += dx*push; a.sy += dy*push;
              b.sx -= dx*push; b.sy -= dy*push;

              // keep within safe screen margins
              a.sx = clamp(a.sx, 20, w-20);
              a.sy = clamp(a.sy, topSafe, h-20);
              b.sx = clamp(b.sx, 20, w-20);
              b.sy = clamp(b.sy, topSafe, h-20);
            }
          }
        }
      }

      // Apply DOM positions + fade when behind
      pts.forEach(p=>{
        const el = p.t.el;
        if(!p.visible){
          el.style.opacity = "0.18";
        }else{
          el.style.opacity = "1";
        }
        el.style.left = p.sx + "px";
        el.style.top  = p.sy + "px";
      });
    }

    function rectForTag(el, x, y){
      const r = el.getBoundingClientRect();
      // approx rect centered at x,y
      return { x: x - r.width/2, y: y - r.height/2, w: r.width, h: r.height };
    }
    function overlap(a,b){
      return !(a.x+a.w < b.x || b.x+b.w < a.x || a.y+a.h < b.y || b.y+b.h < a.y);
    }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    /* ========= Elbow flexion/extension + injury zoom ========= */
    function setElbowAngle(deg){
      document.getElementById("angleReadout").textContent = `${Math.round(deg)}¬∞`;

      // Convert to radians: 0¬∞ roughly straight, positive = flexion.
      // Our foreGroup rotates around X axis (bend).
      const rad = THREE.MathUtils.degToRad(deg);

      // pivot is at foreGroup origin; rotate forearm+hand
      foreGroup.rotation.x = rad;

      // Status thresholds
      const status = document.getElementById("status");
      const banner = document.getElementById("injuryBanner");
      const zoomPill = document.getElementById("zoomPill");

      // Define "safe" approx range: 0..145; risky beyond; injury beyond
      const risky = (deg < 0 || deg > 150);
      const injury = (deg < -8 || deg > 158);

      status.classList.remove("safe","risky","injury");
      if(injury){
        status.textContent="INJURY";
        status.classList.add("injury");
      }else if(risky){
        status.textContent="RISKY";
        status.classList.add("risky");
      }else{
        status.textContent="SAFE";
        status.classList.add("safe");
      }

      //  injury effect
      injuryActive = injury;
      if(injury && !lastInjury){ playInjurySound(); }
      lastInjury = injury;
      injuryLines.visible = injury;
      if(foreGroup.userData.tearLines){
        foreGroup.userData.tearLines.visible = injury;
      }

      banner.classList.toggle("show", injury); banner.style.display = injury ? "block" : "none";

      const mag = document.getElementById("magnifier");
      if(mag){ mag.classList.toggle("show", injury); mag.setAttribute("aria-hidden", injury ? "false" : "true"); }

      // Zoom in when injury reached
      cameraTargetZ = injury ? 5.0 : 8.2;
      zoomPill.textContent = injury ? "üîç Zoom: Injury" : (risky ? "üîç Zoom: Close" : "üîç Zoom: Normal");
      if(!injury && risky) cameraTargetZ = 6.2;
    }

    function resetAll(){
      // reset angle
      const slider = document.getElementById("angle");
      slider.value = 25;
      setElbowAngle(25);

      // reset orbit
      orbit = {x:0.25,y:-0.6};
      dragEnabled = false;
      updateRotateButton();

      // reset selection
      selected = null;
      tags.forEach(t=>t.el.classList.remove("selected"));
      document.getElementById("exTitle").textContent="Click a label";
      document.getElementById("exBody").textContent="Select a part to see an explanation here. Rotation is locked by default so clicks select anatomy.";
    }

    /* ========= Rotation toggle ========= */
    function toggleRotation(){
      dragEnabled = !dragEnabled;
      updateRotateButton();
    }
    function updateRotateButton(){
      const btn = document.getElementById("rotateToggle");
      btn.classList.toggle("enabled", dragEnabled);
      btn.textContent = dragEnabled ? "üîì Enabled" : "üîí Locked";
      renderer.domElement.style.cursor = dragEnabled ? "grab" : "pointer";
    }

    /* ========= Mouse controls ========= */
    function onDown(e){
      if(!dragEnabled) return;
      isDragging=true;
      prev = {x:e.clientX, y:e.clientY};
      renderer.domElement.style.cursor = "grabbing";
    }
    function onMove(e){
      if(!dragEnabled || !isDragging) return;
      const dx = e.clientX - prev.x;
      const dy = e.clientY - prev.y;
      orbit.y += dx * 0.0045;
      orbit.x += dy * 0.0045;
      orbit.x = clamp(orbit.x, -1.2, 1.2);
      prev = {x:e.clientX, y:e.clientY};
    }
    function onUp(){
      isDragging=false;
      if(dragEnabled) renderer.domElement.style.cursor="grab";
    }
    function onWheel(e){
      e.preventDefault();
      // manual zoom (bounded). Still influenced by injury target zoom via smoothing.
      cameraZ += e.deltaY * 0.002;
      cameraZ = clamp(cameraZ, 3.2, 10.0);
    }

    function onCanvasClick(e){
      if(dragEnabled) return; // rotation mode: ignore selection on canvas

      // If click not on a label, do raycast to pick internal parts too
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      // Collect clickable meshes
      const clickable = [];
      scene.traverse(o=>{
        if(o.isMesh && o.userData && o.userData.clickable) clickable.push(o);
      });

      const hits = raycaster.intersectObjects(clickable, true);
      if(hits.length){
        const key = hits[0].object.userData.key || hits[0].object.name;
        if(key) selectKey(key);
      }
    }

    function onResize(){
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    /* ========= Animation loop ========= */
    function animate(){
      requestAnimationFrame(animate);

      // Smooth camera zoom: manual zoom blends toward target zoom
      const target = cameraTargetZ;
      cameraZ = cameraZ + (target - cameraZ) * 0.06;
      camera.position.z = cameraZ;

      // Apply orbit rotation around rig root
      rigRoot.rotation.x = orbit.x;
      rigRoot.rotation.y = orbit.y;

      // Subtle breathing/realism: tiny motion
      const t = performance.now()*0.001;
      rigRoot.position.y = 0.35 + Math.sin(t*1.2)*0.01;

      // Injury "shake" (very mild) when active
      if(injuryActive){
        const s = 0.006;
        camera.position.x = Math.sin(t*28)*s;
        camera.position.y = 1.1 + Math.cos(t*24)*s;
      }else{
        camera.position.x = 0;
        camera.position.y = 1.0;
      }

      updateTags();
      renderer.render(scene, camera);
    }

    
    function setUiVisible(visible){
      const bar = document.getElementById("control-bar");
      const ex = document.getElementById("explain");
      const actions = document.getElementById("top-actions");
      if(bar) bar.style.visibility = visible ? "visible" : "hidden";
      if(ex) ex.style.visibility = visible ? "visible" : "hidden";
      if(actions) actions.style.visibility = visible ? "visible" : "hidden";
      tags.forEach(t=> t.el.style.visibility = visible ? "visible" : "hidden");
    }

    function startLoaderSequence(){
      const loader = document.getElementById("loader");
      const barInner = document.getElementById("barInner");
      const pct = document.getElementById("loaderPct");

      const total = 5000; // 5 seconds
      const t0 = performance.now();

      function tick(){
        const t = performance.now() - t0;
        const p = Math.min(1, t/total);
        const pctVal = Math.round(p*100);
        if(barInner) barInner.style.width = pctVal + "%";
        if(pct) pct.textContent = pctVal + "%";

        if(p < 1){
          requestAnimationFrame(tick);
        }else{
          // Reveal
          if(loader) loader.style.display = "none";
          setUiVisible(true);
          popInArm();
        }
      }
      requestAnimationFrame(tick);
    }

    function popInArm(){
      // Arm pop animation: scale + slight rotate settle, plus sparkles
      const dur = 1200;
      const t0 = performance.now();

      spawnSparkles();

      function easeOutBack(x){
        const c1 = 1.70158;
        const c3 = c1 + 1;
        return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);
      }

      function frame(){
        const t = performance.now() - t0;
        const p = Math.min(1, t/dur);
        const e = easeOutBack(p);

        const s = 0.15 + (0.7225 - 0.15) * e;
        if(rigRoot){
          rigRoot.scale.set(s,s,s);
          rigRoot.rotation.z = (-0.35) * (1 - p); // settle to 0
        }
        if(p < 1) requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);
    }

    function spawnSparkles(){
      // spawn around screen center where the arm appears
      const cx = window.innerWidth * 0.52;
      const cy = window.innerHeight * 0.48;

      for(let i=0;i<28;i++){
        const el = document.createElement("div");
        el.className = "spark";
        el.style.left = cx + "px";
        el.style.top  = cy + "px";

        const ang = (Math.PI*2) * Math.random();
        const dist = 60 + Math.random()*220;
        const dx = Math.cos(ang)*dist;
        const dy = Math.sin(ang)*dist;

        el.style.setProperty("--dx", (cx + dx) + "px");
        el.style.setProperty("--dy", (cy + dy) + "px");
        el.style.animationDelay = (Math.random()*180) + "ms";
        el.style.width = (6 + Math.random()*7) + "px";
        el.style.height = el.style.width;

        document.body.appendChild(el);
        // cleanup
        setTimeout(()=> el.remove(), 1200);
      }
    }


    init();
  </script>
</body>
</html>
